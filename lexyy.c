#define YY_DEFAULT_ACTION ECHO;
#define FLEX_USE_ECS
#define FLEX_USE_MECS
                                    /* A lexical scanner generated by flex */

#include "skeleton.h"

# line 1 "pcalcl.l"
#define INITIAL 0
# line 3 "pcalcl.l"

/*
**  pcalc
*/


#include "ctype.h"
#include "string.h"


#include "hocdecl.h"
#include "symbol.h"
#include "pcalc.h"
#include "convert.h"

extern YYSTYPE yylval;
extern  int lineno;

char    *name;
int     nchar, nword, nline ;

int     count(void);

//define TEST
#define RET_EACH

# line 31 "pcalcl.l"
#define YY_JAM 114
#define YY_JAM_BASE 478
#define YY_TEMPLATE 115
static char l[115] =
    {   0,
       -2,   -2,   54,   28,   27,   26,   42,   54,   54,   48,
       41,   36,   37,   46,   45,   33,   44,   40,   47,   16,
       16,   34,   30,   49,   35,   50,   53,   24,   24,   24,
       24,   24,   24,   24,   38,   39,   51,   24,   24,   24,
       24,   24,   24,   31,   52,   32,   43,   28,    0,   22,
       25,   17,   23,   18,   16,    0,    0,    0,    0,   24,
       24,   24,   24,    9,   24,   24,    5,   24,   24,   10,
       24,   24,    6,   25,   25,    0,   23,   18,    0,    0,
       19,   15,   13,   14,   11,   24,   24,   24,   12,   24,
       24,   24,    0,   21,    0,   20,   15,   13,   14,    7,

       24,   24,    8,   24,   24,   24,    1,   24,    2,   24,
       24,    3,    4,    0
    } ;

static char e[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    5,    6,    1,    7,    8,    9,    1,   10,
       11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
       20,   20,   20,   20,   20,   21,   21,   22,   23,   24,
       25,   26,   27,    1,   28,   29,   29,   30,   31,   32,
       33,   33,   33,   33,   33,   33,   34,   35,   36,   33,
       33,   37,   38,   39,   33,   33,   33,   33,   33,   33,
       40,    1,   41,   42,   33,    1,   43,   29,   44,   45,

       46,   47,   33,   33,   33,   33,   33,   33,   48,   49,
       50,   33,   33,   51,   52,   53,   33,   33,   33,   54,
       55,   33,   56,   57,   58,   59,    1
    } ;

static char m[60] =
    {   0,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    3,    3,    3,
        3,    1,    1,    1,    1,    1,    1,    4,    4,    4,
        4,    4,    5,    5,    5,    5,    5,    5,    5,    1,
        1,    1,    4,    4,    4,    4,    4,    5,    5,    5,
        5,    5,    5,    5,    5,    1,    1,    1,    1
    } ;

static short int b[124] =
    {   0,
        0,    0,  478,  160,  478,  478,  478,  129,    0,  478,
      478,  478,  478,  478,  478,  478,  478,   42,  117,   48,
       21,  478,  478,  478,  478,  478,  478,   52,   62,   70,
       77,   90,   97,  104,  478,  478,  478,  108,  112,  123,
      127,  131,  135,  478,  478,  478,  478,   99,   71,   68,
      140,  146,    0,  150,    0,  184,   66,    0,   81,    0,
      168,  188,  192,  196,  201,  205,  211,  215,  224,  228,
      232,  236,  243,    0,  247,  257,    0,  261,  275,  279,
      283,   86,    0,   94,  290,  294,  298,  302,  306,  311,
      315,  322,  326,  330,  334,  342,  119,    0,  101,  346,

      351,  357,  361,  365,  371,  375,  379,  383,  387,  400,
      404,  408,  417,  478,  450,  452,  455,  458,  463,  466,
      468,  471,  474
    } ;

static short int d[124] =
    {   0,
      114,    1,  114,  114,  114,  114,  114,  115,  116,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
       20,  114,  114,  114,  114,  114,  114,  117,  117,  117,
      117,  117,  117,  117,  114,  114,  114,  117,  117,  117,
      117,  117,  117,  114,  114,  114,  114,  114,  115,  115,
      118,  114,  119,  114,   21,  114,  114,  120,  114,  121,
      117,  117,  117,  117,  117,  117,  117,  117,  117,  117,
      117,  117,  117,  122,  118,  114,  119,  114,  114,  114,
      114,  114,  123,  114,  117,  117,  117,  117,  117,  117,
      117,  117,  114,  114,  114,  114,  114,  123,  114,  117,

      117,  117,  117,  117,  117,  117,  117,  117,  117,  117,
      117,  117,  117,-32767,  114,  114,  114,  114,  114,  114,
      114,  114,  114
    } ;

static short int n[538] =
    {   0,
        3,    4,    5,    6,    7,    8,    9,   10,   11,   12,
       13,   14,   15,   16,   17,   18,   19,   20,   21,   21,
       21,   22,   23,   24,   25,   26,   27,   28,   29,   29,
       29,   30,   29,   29,   29,   31,   32,   33,   34,   35,
       36,   37,   38,   29,   29,   29,   39,   29,   29,   40,
       41,   42,   43,   29,   29,   44,   45,   46,   47,   52,
       52,   52,   52,   54,  114,   55,   55,   55,   55,   60,
       60,   60,   60,   50,  114,  114,   50,   56,   56,   60,
       60,   60,   60,   82,   82,   82,   62,   60,   60,   60,
       60,   57,   56,   56,   60,   60,   60,   60,   84,   84,

       48,   58,   59,   97,   97,   97,   63,   60,   60,   60,
       60,   99,   99,   64,   60,   60,   60,   60,   99,   99,
       65,   60,   60,   60,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   53,   50,   66,   97,   97,   97,   67,
       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   68,   74,   74,   74,
       74,   48,   69,   52,   52,   52,   52,   78,   78,   78,
       78,  114,   71,   70,  114,   76,   76,  114,  114,   79,
       79,  114,  114,   72,   73,   60,   60,   60,   60,  114,
       76,   76,  114,  114,   79,   79,   80,  114,   80,  114,

      114,   81,   81,   81,   81,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60,   85,   60,   60,
       60,   60,   60,   60,   60,   60,  114,   86,   60,   60,
       60,   60,   60,   60,   60,   60,  114,  114,   87,  114,
       88,   60,   60,   60,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60,  114,  114,   89,
       60,   60,   60,   60,   74,   74,   74,   74,  114,   93,
      114,   93,  114,   90,   94,   94,   94,   94,   78,   78,
       78,   78,  114,   91,  114,   92,  114,   95,  114,   95,
       79,   79,   96,   96,   96,   96,   81,   81,   81,   81,

       81,   81,   81,   81,  114,   79,   79,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60,  100,   60,   60,
       60,   60,   60,   60,   60,   60,  101,  114,  102,   60,
       60,   60,   60,   94,   94,   94,   94,   94,   94,   94,
       94,   96,   96,   96,   96,  114,  114,  114,  103,   96,
       96,   96,   96,   60,   60,   60,   60,  104,   60,   60,
       60,   60,  105,  114,   60,   60,   60,   60,   60,   60,
       60,   60,   60,   60,   60,   60,  106,  107,   60,   60,
       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,

       60,   60,   60,   60,   60,   60,   60,   60,  114,  114,
      114,  110,  114,  114,  108,  114,  109,   60,   60,   60,
       60,   60,   60,   60,   60,   60,   60,   60,   60,  114,
      112,  114,  114,  111,   60,   60,   60,   60,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  113,
       49,  114,   49,   49,   49,   51,   51,   61,   61,   61,
       75,   75,   75,   77,  114,   77,   77,   77,   83,   83,
       60,   60,   60,   74,   74,   74,   98,   98,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,

      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114
    } ;

static short int c[538] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,   18,
       18,   18,   18,   20,   21,   20,   20,   20,   20,   28,
       28,   28,   28,   50,   21,   21,   49,   20,   20,   29,
       29,   29,   29,   57,   57,   57,   28,   30,   30,   30,
       30,   20,   20,   20,   31,   31,   31,   31,   59,   59,

       48,   20,   20,   82,   82,   82,   30,   32,   32,   32,
       32,   84,   84,   31,   33,   33,   33,   33,   99,   99,
       32,   34,   34,   34,   34,   38,   38,   38,   38,   39,
       39,   39,   39,   19,    8,   33,   97,   97,   97,   34,
       40,   40,   40,   40,   41,   41,   41,   41,   42,   42,
       42,   42,   43,   43,   43,   43,   38,   51,   51,   51,
       51,    4,   39,   52,   52,   52,   52,   54,   54,   54,
       54,    0,   41,   40,    0,   52,   52,    0,    0,   54,
       54,    0,    0,   42,   43,   61,   61,   61,   61,    0,
       52,   52,    0,    0,   54,   54,   56,    0,   56,    0,

        0,   56,   56,   56,   56,   62,   62,   62,   62,   63,
       63,   63,   63,   64,   64,   64,   64,   62,   65,   65,
       65,   65,   66,   66,   66,   66,    0,   63,   67,   67,
       67,   67,   68,   68,   68,   68,    0,    0,   65,    0,
       66,   69,   69,   69,   69,   70,   70,   70,   70,   71,
       71,   71,   71,   72,   72,   72,   72,    0,    0,   68,
       73,   73,   73,   73,   75,   75,   75,   75,    0,   76,
        0,   76,    0,   69,   76,   76,   76,   76,   78,   78,
       78,   78,    0,   71,    0,   72,    0,   79,    0,   79,
       78,   78,   79,   79,   79,   79,   80,   80,   80,   80,

       81,   81,   81,   81,    0,   78,   78,   85,   85,   85,
       85,   86,   86,   86,   86,   87,   87,   87,   87,   88,
       88,   88,   88,   89,   89,   89,   89,   86,   90,   90,
       90,   90,   91,   91,   91,   91,   87,    0,   88,   92,
       92,   92,   92,   93,   93,   93,   93,   94,   94,   94,
       94,   95,   95,   95,   95,    0,    0,    0,   90,   96,
       96,   96,   96,  100,  100,  100,  100,   91,  101,  101,
      101,  101,   92,    0,  102,  102,  102,  102,  103,  103,
      103,  103,  104,  104,  104,  104,  101,  102,  105,  105,
      105,  105,  106,  106,  106,  106,  107,  107,  107,  107,

      108,  108,  108,  108,  109,  109,  109,  109,    0,    0,
        0,  106,    0,    0,  104,    0,  105,  110,  110,  110,
      110,  111,  111,  111,  111,  112,  112,  112,  112,    0,
      110,    0,    0,  108,  113,  113,  113,  113,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,  111,
      115,    0,  115,  115,  115,  116,  116,  117,  117,  117,
      118,  118,  118,  119,    0,  119,  119,  119,  120,  120,
      121,  121,  121,  122,  122,  122,  123,  123,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,

      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114,  114,  114,  114,
      114,  114,  114,  114,  114,  114,  114
    } ;


/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin = stdin, *yyout = stdout;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;

static char input( void) ;
static void unput( char) ;

char *yytext;
static int yyleng;

/*-------------------------------------------------------------------------*/
/*------------------------- BEGIN LEXICAL ANALYZER ------------------------*/
/*-------------------------------------------------------------------------*/

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;
#ifdef FLEX_REJECT_ENABLED
    int yy_full_match;
#endif





    if ( yy_init )
    {
    YY_INIT;
    yy_start = 1;
    yy_init = 0;
    }

    goto get_next_token;

do_action:

#ifdef FLEX_REJECT_ENABLED
       /* remember matched text in case we back up due to trailing context */
    yy_full_match = yy_c_buf_p;
#endif

    for ( ; ; )
    {
    YY_DO_BEFORE_ACTION

#ifdef FLEX_DEBUG
    fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
    switch ( yy_act )
        {
case 1:
# line 35 "pcalcl.l"
case 2:
# line 35 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(STORE);
                                #endif
                                }
	YY_BREAK
case 3:
# line 43 "pcalcl.l"
case 4:
# line 43 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(RESTORE);
                                #endif
                                }
	YY_BREAK
case 5:
# line 52 "pcalcl.l"
case 6:
# line 52 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(TO);
                                #endif
                                }
	YY_BREAK
case 7:
# line 61 "pcalcl.l"
case 8:
# line 61 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(FROM);
                                #endif
                                }
	YY_BREAK
case 9:
# line 71 "pcalcl.l"
case 10:
# line 71 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('|');
                                #endif
                                }
	YY_BREAK
case 11:
# line 80 "pcalcl.l"
case 12:
# line 80 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('&');
                                #endif
                                }
	YY_BREAK
case 13:
# line 88 "pcalcl.l"
{
                                #ifdef TEST
                                printf(" Hexadec: [ %s ]\n", yytext);
                                #endif

                                yylval.val = (double) hextol(yytext + 2);

                                #ifdef RET_EACH
                                return(NUMBER);
                                #endif
                                }
	YY_BREAK
case 14:
# line 100 "pcalcl.l"
{
                                #ifdef TEST
                                printf(" Binary:  [ %s ]\n", yytext);
                                #endif

                                yylval.val = bintol(yytext + 2);

                                #ifdef RET_EACH
                                return(NUMBER);
                                #endif
                                }
	YY_BREAK
case 15:
# line 112 "pcalcl.l"
{
                                #ifdef TEST
                                printf(" Octal:   [ %s ]\n", yytext);
                                #endif

                                yylval.val = otol(yytext + 2);

                                #ifdef RET_EACH
                                return(NUMBER);
                                #endif
                                }
	YY_BREAK
case 16:
# line 124 "pcalcl.l"
{
                                #ifdef TEST
                                printf(" Decimal: [ %s ]\n", yytext);
                                #endif

                                yylval.val = (double) atol(yytext);

                                #ifdef RET_EACH
                                return(NUMBER);
                                #endif
                                }
	YY_BREAK
case 17:
# line 137 "pcalcl.l"
case 18:
# line 138 "pcalcl.l"
case 19:
# line 139 "pcalcl.l"
case 20:
# line 140 "pcalcl.l"
case 21:
# line 140 "pcalcl.l"
{
                                #ifdef TEST
                                printf(" Decimal: [ %s ]\n", yytext);
                                #endif

                                yylval.val = (double) atof(yytext);

                                #ifdef RET_EACH
                                return(NUMBER);
                                #endif
                                }
	YY_BREAK
case 22:
# line 152 "pcalcl.l"
{
                                Symbol *sp;

                                #ifdef TEST
                                printf(" string: [ %s ]\n", yytext);
                                #endif

                                sp  = lookup_sym(yytext);

                                if(sp)
                                    {
                                    yylval.sym = sp;
                                    return(sp->type);
                                    }
                                else
                                    {
                                    /*
                                     * Kill " "
                                     */
                                    yytext[strlen(yytext) - 1] = '\0';
                                    sp = install_sym(yytext + 1, STR, 0.0);
                                    sp->u.str = sp->name;   //str = strval
                                    yylval.sym = sp;
                                    }

                                #ifdef RET_EACH
                                return(STR);
                                #endif
                                }
	YY_BREAK
case 23:
# line 183 "pcalcl.l"
{
                                #ifdef TEST
                                printf(" Comment: [ %s ]\n", yytext);
                                #endif

                                #ifdef RET_EACH
                                //return(COMM);
                                #endif
                                }
	YY_BREAK
case 24:
# line 193 "pcalcl.l"
{
                                Symbol *sp;

                                #ifdef TEST
                                printf(" Ident:   [ %s ]\n", yytext);
                                #endif

                                sp  = lookup_sym(yytext);

                                if(sp)
                                    {
                                    yylval.sym = sp;

                                    if(sp->type == BUILTIN)
                                        {
                                        #ifdef TEST
                                        printf("Bultin: %s\n", sp->name );
                                        #endif

                                        #ifdef RET_EACH
                                        return(BUILTIN);
                                        #endif
                                        }
                                    else if(sp->type == IBUILTIN)
                                        {
                                        #ifdef TEST
                                        printf("Bultin: %s\n", sp->name );
                                        #endif

                                        #ifdef RET_EACH
                                        return(IBUILTIN);
                                        #endif
                                        }
                                    else if(sp->type == VAR)
                                        {
                                        #ifdef TEST
                                        printf("Var: %s\n", sp->name );
                                        #endif

                                        #ifdef RET_EACH
                                        return(VAR);
                                        #endif
                                        }
                                    }
                                else
                                    {
                                    sp = install_sym(yytext, VAR, 0.0);
                                    yylval.sym = sp;
                                    //yylval.sym->u.val = 0.0;

                                    #ifdef RET_EACH
                                    return(VAR);
                                    #endif
                                    }
                                }
	YY_BREAK
case 25:
# line 249 "pcalcl.l"
{

                                yylval.sym = lookup_sym(yytext);

                                if(!yylval.sym)
                                    {
                                    yylval.sym =
                                        install_sym(yytext, STRVAR, 0.0);
                                    }

                                #ifdef TEST
                                printf(" Stringvar: [ %s ]\n", yytext);
                                #endif

                                #ifdef RET_EACH
                                return(STRVAR);
                                #endif
                                }
	YY_BREAK
case 26:
# line 268 "pcalcl.l"
{
                                #ifdef TEST
                                printf(" Comment: [ %s ]\n", yytext);
                                #endif

                                #ifdef RET_EACH
                                lineno++;
                                //return(COMM);
                                #endif
                                }
	YY_BREAK
case 27:
# line 279 "pcalcl.l"
{   }
	YY_BREAK
case 28:
# line 281 "pcalcl.l"
{
                                #ifdef TEST
                                //printf(" White:   [ %s ]\n", yytext);
                                #endif

                                #ifdef RET_EACH
                                //return(WHITE);
                                #endif
                                }
	YY_BREAK
case 29:
# line 291 "pcalcl.l"
{
                                #ifdef TEST
                                printf(" String:  [ %s ]\n", yytext);
                                #endif

                                #ifdef RET_EACH
                                //return(STR);
                                #endif
                                }
	YY_BREAK
case 30:
# line 301 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(';');
                                #endif
                                }
	YY_BREAK
case 31:
# line 309 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('{');
                                #endif
                                }
	YY_BREAK
case 32:
# line 317 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('}');
                                #endif
                                }
	YY_BREAK
case 33:
# line 325 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(',');
                                #endif
                                }
	YY_BREAK
case 34:
# line 333 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(':');
                                #endif
                                }
	YY_BREAK
case 35:
# line 341 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('=');
                                #endif
                                }
	YY_BREAK
case 36:
# line 349 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('(');
                                #endif
                                }
	YY_BREAK
case 37:
# line 357 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(')');
                                #endif
                                }
	YY_BREAK
case 38:
# line 365 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('[');
                                #endif
                                }
	YY_BREAK
case 39:
# line 373 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return(']');
                                #endif
                                }
	YY_BREAK
case 40:
# line 381 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('.');
                                #endif
                                }
	YY_BREAK
case 41:
# line 389 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('&');
                                #endif
                                }
	YY_BREAK
case 42:
# line 397 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('!');
                                #endif
                                }
	YY_BREAK
case 43:
# line 405 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('~');
                                #endif
                                }
	YY_BREAK
case 44:
# line 413 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('-');
                                #endif
                                }
	YY_BREAK
case 45:
# line 421 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('+');
                                #endif
                                }
	YY_BREAK
case 46:
# line 429 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('*');
                                #endif
                                }
	YY_BREAK
case 47:
# line 437 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('/');
                                #endif
                                }
	YY_BREAK
case 48:
# line 445 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('%');
                                #endif
                                }
	YY_BREAK
case 49:
# line 453 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('<');
                                #endif
                                }
	YY_BREAK
case 50:
# line 461 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('>');
                                #endif
                                }
	YY_BREAK
case 51:
# line 469 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('^');
                                #endif
                                }
	YY_BREAK
case 52:
# line 477 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('|');
                                #endif
                                }
	YY_BREAK
case 53:
# line 485 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                return('?');
                                #endif
                                }
	YY_BREAK
case 54:
# line 493 "pcalcl.l"
{
                                count();

                                #ifdef RET_EACH
                                //return(yytext[0]);
                                #endif
                               }                    /* ignore all the rest */
	YY_BREAK
case 55:
# line 501 "pcalcl.l"
YY_DEFAULT_ACTION;
	YY_BREAK

case YY_NEW_FILE:
break;                                      /* begin reading from new file */

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
        }

get_next_token:
    {
    register int yy_curst;
    register char yy_sym;

    YY_DO_BEFORE_SCAN

                                            /* set up to begin running DFA */

    yy_curst = yy_start;

    if ( yy_ch_buf[yy_c_buf_p] == '\n' )
        ++yy_curst;

    /* yy_b_buf_p points to the position in yy_ch_buf
     * of the start of the current run.
     */

    yy_b_buf_p = yy_c_buf_p + 1;

    do                                           /* until the machine jams */
        {
        if ( yy_c_buf_p == yy_e_buf_p )
       {                                                /* need more input */
       if ( yy_e_buf_p >= YY_BUF_LIM )
           {                         /* not enough room to do another read */
                            /* see if we can make some room for more chars */

           yy_n_chars = yy_e_buf_p - yy_b_buf_p;

           if ( yy_n_chars >= 0 )
                                         /* shift down buffer to make room */
         for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
             {
             yy_buf_pos = yy_b_buf_p + yy_iii;
             yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
             yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
             }

           yy_b_buf_p = 0;
           yy_e_buf_p = yy_n_chars;

           if ( yy_e_buf_p >= YY_BUF_LIM )
         YY_FATAL_ERROR( "flex input buffer overflowed" );

           yy_c_buf_p = yy_e_buf_p;
           }

       else if ( yy_saw_eof )
           {
saweof:         if ( yy_b_buf_p > yy_e_buf_p )
         {
         if ( yywrap() )
             {
             yy_act = YY_END_TOK;
             goto do_action;
             }
         
         else
             {
             YY_INIT;
             yy_act = YY_NEW_FILE;
             goto do_action;
             }
         }

           else                           /* do a jam to eat up more input */
         {
#ifndef FLEX_INTERACTIVE_SCANNER
         /* we're going to decrement yy_c_buf_p upon doing
          * the jam.  In this case, that's wrong, since
          * it points to the last non-jam character.  So
          * we increment it now to counter the decrement.
          */
         ++yy_c_buf_p;
#endif
         break;
         }
           }

       YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
           YY_MAX_LINE );

       if ( yy_n_chars == YY_NULL )
           {
           if ( yy_saw_eof )
    YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
           yy_saw_eof = 1;
           goto saweof;
           }

       yy_e_buf_p += yy_n_chars;
       }

        ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
        yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
        yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

#ifdef FLEX_FULL_TABLE
        yy_curst = n[yy_curst][yy_sym];

#else                              /* get next state from compressed table */

        while ( c[b[yy_curst] + yy_sym] != yy_curst )
       {
       yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
       /* we've arrange it so that templates are never chained
        * to one another.  This means we can afford make a
        * very simple test to see if we need to convert to
        * yy_sym's meta-equivalence class without worrying
        * about erroneously looking up the meta-equivalence
        * class twice
        */

       if ( yy_curst >= YY_TEMPLATE )
           yy_sym = m[yy_sym];
#endif
       }

        yy_curst = n[b[yy_curst] + yy_sym];

#endif

        yy_st_buf[yy_c_buf_p] = yy_curst;

        }
#ifdef FLEX_INTERACTIVE_SCANNER
    while ( b[yy_curst] != YY_JAM_BASE );
#else
    while ( yy_curst != YY_JAM );
    --yy_c_buf_p;                       /* put back character we jammed on */

#endif

    if ( yy_c_buf_p >= yy_b_buf_p )
        {                                          /* we matched some text */
        yy_curst = yy_st_buf[yy_c_buf_p];
        yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule:                  /* we branch to this label when doing a REJECT */
#endif

        for ( ; ; )                  /* until we find what rule we matched */
       {
#ifdef FLEX_REJECT_ENABLED
       if ( yy_lp && yy_lp < l[yy_curst + 1] )
           {
           yy_act = a[yy_lp];
           goto do_action;                                 /* "continue 2" */
           }
#else
       if ( yy_lp )
           {
           yy_act = yy_lp;
           goto do_action;                                 /* "continue 2" */
           }
#endif

       if ( --yy_c_buf_p < yy_b_buf_p )
           break;

       yy_curst = yy_st_buf[yy_c_buf_p];
       yy_lp = l[yy_curst];
       }
        }

    YY_FATAL_ERROR( "no match in flex scanner - possible NULL in input" );
    }
    }

                                                               /*NOTREACHED*/
    }

static  void unput( c )
char c;
{
 register int i;
 register int yy_buf_pos ;

    YY_DO_BEFORE_SCAN;                /* undo effects of setting up yytext */

    if ( yy_c_buf_p == 0 )
    {
    yy_buf_pos = YY_BUF_MAX ;
    for ( i = yy_e_buf_p; i >= yy_c_buf_p; --i )
        {
        yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
        yy_st_buf[yy_buf_pos] = yy_st_buf[i];
        --yy_buf_pos;
        }

    yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
    yy_e_buf_p = YY_BUF_MAX;
    }

    if ( yy_c_buf_p <= 0 )
    YY_FATAL_ERROR( "flex scanner push-back overflow" );

    if ( yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n' )
    yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] =  c;

    YY_DO_BEFORE_ACTION;                            /* set up yytext again */

    }

static char input( void)
{
    char c;

    YY_DO_BEFORE_SCAN

    if ( yy_c_buf_p == yy_e_buf_p )
    {                                                   /* need more input */
    int yy_n_chars;

                            /* we can throw away the entire current buffer */
    if ( yy_saw_eof )
        {
        if ( yywrap() )
       return ( EOF );

        YY_INIT;
        }

    yy_b_buf_p = 0;
    YY_INPUT( yy_ch_buf, yy_n_chars, YY_MAX_LINE );

    if ( yy_n_chars == YY_NULL )
    {
        yy_saw_eof = 1;

        if ( yywrap() )
       return ( EOF );

        YY_INIT;

        return ( input() );
    }

    yy_c_buf_p = -1;
    yy_e_buf_p = yy_n_chars - 1;
    }

    c = (unsigned char) yy_ch_buf[++yy_c_buf_p];

    YY_DO_BEFORE_ACTION;

    return ( c );
    }

/*-------------------------------------------------------------------------*/
/*------------------------- END OF LEXICAL ANALYZER -----------------------*/
/*-------------------------------------------------------------------------*/

# line 501 "pcalcl.l"


int     count(void)

{

}